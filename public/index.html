<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SKULL â€” Multiplayer</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700;900&family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --surface2: #1a1a24;
    --border: #2a2a3a;
    --gold: #d4a843;
    --gold-dim: #8a6d2b;
    --rose: #c44569;
    --rose-dark: #7a2a40;
    --skull: #8b9dc3;
    --skull-dark: #4a5570;
    --text: #e8e4dc;
    --text-dim: #7a7680;
    --danger: #e74c3c;
    --success: #2ecc71;
  }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Crimson Text', serif;
    min-height: 100vh;
    overflow-x: hidden;
  }
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 50%, rgba(212,168,67,0.03) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 20%, rgba(196,69,105,0.03) 0%, transparent 60%),
      radial-gradient(ellipse at 50% 80%, rgba(139,157,195,0.03) 0%, transparent 60%);
    pointer-events: none; z-index: 0;
  }
  .container { position: relative; z-index: 1; max-width: 1400px; margin: 0 auto; padding: 24px; min-height: 100vh; }

  /* â”€â”€ Title â”€â”€ */
  .title-bar { text-align: center; padding: 24px 0 12px; }
  .title-bar h1 { font-family: 'Cinzel Decorative', serif; font-size: 2.8rem; color: var(--gold); letter-spacing: 0.15em; text-shadow: 0 0 30px rgba(212,168,67,0.2); }
  .title-bar .sub { font-family: 'Cinzel', serif; font-size: 0.9rem; color: var(--text-dim); letter-spacing: 0.3em; margin-top: 4px; }

  /* â”€â”€ Screens â”€â”€ */
  .screen { display: none; animation: fadeIn 0.4s ease; }
  .screen.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

  /* â”€â”€ Lobby â”€â”€ */
  .lobby-box {
    max-width: 480px; margin: 50px auto; background: var(--surface); border: 1px solid var(--border);
    border-radius: 16px; padding: 36px; text-align: center;
  }
  .lobby-box h2 { font-family: 'Cinzel Decorative', serif; font-size: 1.9rem; color: var(--gold); margin-bottom: 24px; }
  .lobby-box input {
    width: 100%; padding: 14px 18px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text); font-family: 'Crimson Text', serif; font-size: 1.2rem;
    text-align: center; margin-bottom: 14px; outline: none; transition: border-color 0.2s;
  }
  .lobby-box input:focus { border-color: var(--gold); }
  .lobby-box input::placeholder { color: var(--text-dim); }
  .lobby-box .or { color: var(--text-dim); margin: 16px 0; font-family: 'Cinzel', serif; font-size: 0.85rem; letter-spacing: 0.2em; }
  .btn {
    font-family: 'Cinzel', serif; font-size: 1.05rem; padding: 14px 34px; border-radius: 8px;
    cursor: pointer; transition: all 0.2s; letter-spacing: 0.06em; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text); display: inline-block;
  }
  .btn:hover:not(:disabled) { border-color: var(--gold); color: var(--gold); transform: translateY(-1px); }
  .btn:disabled { opacity: 0.3; cursor: not-allowed; }
  .btn.primary { background: linear-gradient(135deg, var(--gold-dim), var(--gold)); color: var(--bg); border: none; font-weight: 700; }
  .btn.primary:hover:not(:disabled) { color: var(--bg); box-shadow: 0 4px 20px rgba(212,168,67,0.3); }
  .btn.danger { border-color: var(--danger); color: var(--danger); }
  .btn.sm { padding: 12px 24px; font-size: 1rem; }
  .error-msg { color: var(--danger); margin-top: 10px; font-size: 0.95rem; }

  /* â”€â”€ Waiting Room â”€â”€ */
  .room-code-display {
    font-family: 'Cinzel Decorative', serif; font-size: 3.2rem; color: var(--gold);
    letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(212,168,67,0.3); margin: 12px 0;
    cursor: pointer; user-select: all;
  }
  .room-code-display:hover { text-shadow: 0 0 40px rgba(212,168,67,0.5); }
  .copy-hint { font-size: 0.95rem; color: var(--text-dim); margin-bottom: 24px; }
  .player-list { list-style: none; margin: 24px 0; }
  .player-list li {
    padding: 12px 18px; margin: 8px 0; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 8px; font-family: 'Cinzel', serif; font-size: 1.1rem; display: flex;
    justify-content: space-between; align-items: center;
  }
  .player-list .host-badge { font-size: 0.85rem; color: var(--gold); letter-spacing: 0.1em; }
  .player-list .you-badge { font-size: 0.85rem; color: var(--skull); letter-spacing: 0.1em; }
  .player-color-dot {
    display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; vertical-align: middle;
  }
  .waiting-dots::after { content: ''; animation: dots 1.5s infinite; }
  @keyframes dots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }

  /* â”€â”€ Game Board â”€â”€ */
  .status-bar {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 24px; background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; margin-bottom: 16px; flex-wrap: wrap; gap: 8px;
  }
  .phase-label { font-family: 'Cinzel', serif; font-size: 1.15rem; color: var(--gold); letter-spacing: 0.08em; }
  .round-label { font-size: 1.05rem; color: var(--text-dim); }
  .bid-info { font-family: 'Cinzel', serif; font-size: 1.1rem; color: var(--rose); }
  .coasters-info { font-size: 0.95rem; color: var(--text-dim); }

  /* â”€â”€ Turn Timer â”€â”€ */
  .turn-timer {
    height: 4px; background: var(--surface2); border-radius: 2px; margin-top: 6px; overflow: hidden;
  }
  .turn-timer-bar {
    height: 100%; border-radius: 2px; transition: width 1s linear, background-color 1s linear;
  }

  .message-area {
    text-align: center; padding: 16px; min-height: 56px; font-size: 1.3rem; line-height: 1.5;
  }
  .hl { color: var(--gold); font-weight: 600; }
  .rose-hl { color: var(--rose); }
  .skull-hl { color: var(--skull); }

  /* â”€â”€ Player Zones â”€â”€ */
  .players-grid {
    display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; margin-bottom: 18px;
  }
  .player-zone {
    background: var(--surface); border: 1px solid var(--border); border-radius: 14px;
    padding: 18px 22px; min-width: 200px; flex: 1; max-width: 280px; transition: all 0.3s;
    position: relative;
  }
  .player-zone.is-me { border-color: var(--gold-dim); }
  .player-zone.active-turn { border-color: var(--gold); box-shadow: 0 0 18px rgba(212,168,67,0.12); }
  .player-zone.eliminated { opacity: 0.3; }
  .player-zone.disconnected { opacity: 0.5; }
  .pz-header {
    display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
  }
  .pz-name { font-family: 'Cinzel', serif; font-size: 1.05rem; color: var(--text-dim); }
  .pz-name.is-me-name { color: var(--gold); }
  .pz-wins { display: flex; gap: 5px; }
  .win-pip {
    width: 14px; height: 14px; border-radius: 50%; border: 1.5px solid var(--gold-dim); background: transparent;
  }
  .win-pip.earned { background: var(--gold); border-color: var(--gold); box-shadow: 0 0 8px rgba(212,168,67,0.5); }
  .pz-cards-info { font-size: 0.9rem; color: var(--text-dim); margin-bottom: 8px; }

  .stack-row { display: flex; gap: 8px; justify-content: center; min-height: 60px; align-items: center; flex-wrap: wrap; }

  .coaster {
    width: 56px; height: 56px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-size: 1.3rem; transition: all 0.3s; position: relative; cursor: default;
  }
  .coaster.facedown { background: var(--surface2); border: 2px solid var(--border); box-shadow: inset 0 0 6px rgba(0,0,0,0.3); }
  .coaster.facedown::after { content: '?'; color: var(--text-dim); font-family: 'Cinzel Decorative', serif; font-size: 1.1rem; }
  .coaster.rose { background: radial-gradient(circle, var(--rose), var(--rose-dark)); border: 2px solid var(--rose); box-shadow: 0 0 10px rgba(196,69,105,0.3); }
  .coaster.rose::after { content: 'ðŸŒ¹'; font-size: 1.4rem; }
  .coaster.skull { background: radial-gradient(circle, var(--skull), var(--skull-dark)); border: 2px solid var(--skull); box-shadow: 0 0 10px rgba(139,157,195,0.3); }
  .coaster.skull::after { content: 'ðŸ’€'; font-size: 1.4rem; }
  .coaster.in-hand { background: var(--surface2); border: 2px dashed var(--border); opacity: 0.3; }
  .coaster.in-hand::after { content: ''; }
  .coaster.flippable { cursor: pointer; animation: pulse 1.5s infinite; }
  .coaster.flippable:hover { transform: scale(1.15); box-shadow: 0 0 14px rgba(212,168,67,0.4); border-color: var(--gold); }
  .coaster.peekable { cursor: help; }
  .coaster.peekable:hover::after { font-size: 1.4rem; }
  .coaster.peek-rose:hover { border-color: var(--rose); box-shadow: 0 0 10px rgba(196,69,105,0.3); }
  .coaster.peek-rose:hover::after { content: 'ðŸŒ¹' !important; }
  .coaster.peek-skull:hover { border-color: var(--skull); box-shadow: 0 0 10px rgba(139,157,195,0.3); }
  .coaster.peek-skull:hover::after { content: 'ðŸ’€' !important; }
  @keyframes pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(212,168,67,0.2); } 50% { box-shadow: 0 0 0 5px rgba(212,168,67,0); } }

  /* â”€â”€ Flip Animation â”€â”€ */
  .coaster.flip-anim {
    animation: flipCard 0.6s ease forwards;
  }
  @keyframes flipCard {
    0% { transform: rotateY(0deg); }
    50% { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
  }

  /* â”€â”€ Your Hand â”€â”€ */
  .your-hand-section {
    background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
    padding: 24px; margin-top: 16px;
  }
  .your-hand-section.your-turn { border-color: var(--gold); box-shadow: 0 0 24px rgba(212,168,67,0.1); }
  .your-hand-label { font-family: 'Cinzel', serif; font-size: 1.1rem; color: var(--gold); margin-bottom: 14px; text-align: center; letter-spacing: 0.06em; }
  .hand-cards { display: flex; gap: 18px; justify-content: center; flex-wrap: wrap; }

  .hand-card {
    width: 100px; height: 100px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-size: 2.6rem; cursor: pointer; transition: all 0.25s;
  }
  .hand-card.rose-card { background: radial-gradient(circle, rgba(196,69,105,0.2), rgba(196,69,105,0.05)); border: 2.5px solid var(--rose-dark); }
  .hand-card.rose-card:hover:not(.disabled) { border-color: var(--rose); transform: translateY(-6px); box-shadow: 0 8px 24px rgba(196,69,105,0.25); }
  .hand-card.skull-card { background: radial-gradient(circle, rgba(139,157,195,0.2), rgba(139,157,195,0.05)); border: 2.5px solid var(--skull-dark); }
  .hand-card.skull-card:hover:not(.disabled) { border-color: var(--skull); transform: translateY(-6px); box-shadow: 0 8px 24px rgba(139,157,195,0.25); }
  .hand-card.disabled { opacity: 0.2; cursor: not-allowed; }

  /* â”€â”€ Actions â”€â”€ */
  .actions-bar { display: flex; gap: 14px; justify-content: center; margin-top: 18px; flex-wrap: wrap; align-items: center; }
  .bid-controls { display: flex; align-items: center; gap: 14px; }
  .bid-number { font-family: 'Cinzel Decorative', serif; font-size: 2.4rem; color: var(--gold); min-width: 50px; text-align: center; }
  .bid-arrow {
    width: 46px; height: 46px; border-radius: 50%; background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); font-size: 1.3rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
  }
  .bid-arrow:hover:not(:disabled) { border-color: var(--gold); color: var(--gold); }
  .bid-arrow:disabled { opacity: 0.3; cursor: not-allowed; }

  /* â”€â”€ Revealed Cards â”€â”€ */
  .revealed-area {
    display: flex; gap: 14px; justify-content: center; flex-wrap: wrap; margin: 14px 0;
    min-height: 0;
  }
  .revealed-card {
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    animation: revealPop 0.4s ease;
  }
  .revealed-card .rc-name { font-size: 0.85rem; color: var(--text-dim); font-family: 'Cinzel', serif; }
  @keyframes revealPop { from { transform: scale(0.5) rotateY(90deg); opacity: 0; } to { transform: scale(1) rotateY(0); opacity: 1; } }

  /* â”€â”€ Game Log + Chat â”€â”€ */
  .log-chat-wrapper { margin-top: 20px; }
  .game-log {
    padding: 16px 20px; background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px 12px 0 0; max-height: 160px; overflow-y: auto; font-size: 0.95rem;
    color: var(--text-dim); line-height: 1.8;
  }
  .game-log::-webkit-scrollbar { width: 4px; }
  .game-log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .chat-input-row {
    display: flex; gap: 0; background: var(--surface); border: 1px solid var(--border);
    border-top: none; border-radius: 0 0 12px 12px; overflow: hidden;
  }
  .chat-input-row input {
    flex: 1; padding: 10px 16px; background: var(--surface2); border: none; color: var(--text);
    font-family: 'Crimson Text', serif; font-size: 1rem; outline: none;
  }
  .chat-input-row input::placeholder { color: var(--text-dim); }
  .chat-input-row button {
    padding: 10px 18px; background: var(--surface2); border: none; border-left: 1px solid var(--border);
    color: var(--gold); font-family: 'Cinzel', serif; font-size: 0.9rem; cursor: pointer; transition: background 0.2s;
  }
  .chat-input-row button:hover { background: var(--border); }

  /* â”€â”€ Win Overlay â”€â”€ */
  .win-overlay {
    display: none; position: fixed; inset: 0; background: rgba(10,10,15,0.92); z-index: 100;
    justify-content: center; align-items: center; flex-direction: column; gap: 20px;
  }
  .win-overlay.active { display: flex; animation: fadeIn 0.5s ease; }
  .win-overlay h2 { font-family: 'Cinzel Decorative', serif; font-size: 3.4rem; color: var(--gold); text-shadow: 0 0 50px rgba(212,168,67,0.4); }
  .win-overlay p { font-size: 1.4rem; color: var(--text-dim); }

  /* â”€â”€ Rules / Stats / Mute â”€â”€ */
  .fixed-btns { position: fixed; bottom: 18px; right: 18px; display: flex; gap: 8px; z-index: 50; }
  .circle-btn {
    width: 40px; height: 40px; border-radius: 50%;
    background: var(--surface2); border: 1px solid var(--border); color: var(--text-dim);
    font-family: 'Cinzel', serif; font-size: 1rem; cursor: pointer; transition: all 0.2s;
    display: flex; align-items: center; justify-content: center;
  }
  .circle-btn:hover { border-color: var(--gold); color: var(--gold); }
  .circle-btn.active { border-color: var(--gold); color: var(--gold); }
  .rules-modal, .stats-modal { display: none; position: fixed; inset: 0; background: rgba(10,10,15,0.9); z-index: 100; justify-content: center; align-items: center; padding: 20px; }
  .rules-modal.active, .stats-modal.active { display: flex; }
  .rules-content, .stats-content {
    background: var(--surface); border: 1px solid var(--border); border-radius: 14px; padding: 28px;
    max-width: 520px; max-height: 80vh; overflow-y: auto; line-height: 1.7; font-size: 0.92rem;
  }
  .rules-content h3, .stats-content h3 { font-family: 'Cinzel', serif; color: var(--gold); margin: 14px 0 6px; font-size: 1rem; }
  .rules-content h3:first-child, .stats-content h3:first-child { margin-top: 0; }
  .rules-content .close-rules, .stats-content .close-stats { float: right; background: none; border: none; color: var(--text-dim); font-size: 1.3rem; cursor: pointer; }
  .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); }
  .stat-label { color: var(--text-dim); }
  .stat-value { color: var(--gold); font-weight: 600; }
  .recent-game { padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.88rem; }
  .recent-game .rg-date { color: var(--text-dim); }
  .recent-game .rg-winner { color: var(--gold); }

  /* â”€â”€ Doug Overlay â”€â”€ */
  .doug-overlay {
    display: none; position: fixed; inset: 0; z-index: 300;
    background: #000; justify-content: center; align-items: center; flex-direction: column;
    overflow: hidden;
  }
  .doug-overlay.active { display: flex; animation: screenShake 0.6s ease; }
  @keyframes screenShake {
    0%, 100% { transform: translate(0); }
    10% { transform: translate(-15px, 8px); }
    20% { transform: translate(12px, -10px); }
    30% { transform: translate(-8px, 12px); }
    40% { transform: translate(15px, -5px); }
    50% { transform: translate(-10px, -8px); }
    60% { transform: translate(8px, 10px); }
    70% { transform: translate(-12px, -6px); }
    80% { transform: translate(10px, 8px); }
    90% { transform: translate(-5px, -12px); }
  }
  .doug-text {
    font-family: 'Cinzel Decorative', serif; font-size: clamp(3rem, 10vw, 7rem);
    color: #ff0000; text-shadow: 0 0 30px #ff0000, 0 0 60px #ff4400, 0 0 100px #ff0000;
    animation: dougPulse 0.15s infinite alternate; text-align: center;
    z-index: 2; position: relative; line-height: 1.2;
  }
  @keyframes dougPulse {
    from { transform: scale(1) rotate(-1deg); text-shadow: 0 0 30px #ff0000, 0 0 60px #ff4400; }
    to { transform: scale(1.08) rotate(1deg); text-shadow: 0 0 50px #ff0000, 0 0 100px #ff4400, 0 0 150px #ff0000; }
  }
  .doug-particle {
    position: absolute; border-radius: 50%; pointer-events: none; z-index: 1;
  }
  .doug-close { margin-top: 40px; z-index: 2; position: relative; }
  .doug-btn {
    background: #e74c3c !important; border-color: #c0392b !important; color: #fff !important;
    font-size: 1.1rem !important; animation: dougBtnPulse 1.5s infinite;
  }
  @keyframes dougBtnPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(231,76,60,0.4); }
    50% { box-shadow: 0 0 12px 4px rgba(231,76,60,0.6); }
  }

  @media (max-width: 600px) {
    .title-bar h1 { font-size: 1.6rem; }
    .room-code-display { font-size: 2.2rem; }
    .player-zone { min-width: 130px; padding: 12px; }
    .hand-card { width: 72px; height: 72px; font-size: 1.8rem; }
    .coaster { width: 44px; height: 44px; }
    .message-area { font-size: 1.05rem; }
    .btn.sm { padding: 10px 18px; font-size: 0.9rem; }
  }
</style>
</head>
<body>

<div class="container">
  <div class="title-bar">
    <h1>â˜  SKULL â˜ </h1>
    <div class="sub">MULTIPLAYER BLUFFING</div>
  </div>

  <!-- â”€â”€ Lobby Screen â”€â”€ -->
  <div class="screen active" id="lobbyScreen">
    <div class="lobby-box">
      <h2>ENTER</h2>
      <input type="text" id="nameInput" placeholder="Your name" maxlength="16" autocomplete="off">
      <br>
      <button class="btn primary" onclick="createRoom()" style="width:100%">CREATE ROOM</button>
      <div class="or">â€” OR JOIN â€”</div>
      <input type="text" id="codeInput" placeholder="Room code" maxlength="4" autocomplete="off" style="text-transform:uppercase; letter-spacing:0.3em; font-family:'Cinzel',serif; font-size:1.3rem;">
      <br>
      <button class="btn" onclick="joinRoom()" style="width:100%">JOIN ROOM</button>
      <div class="error-msg" id="lobbyError"></div>
    </div>
  </div>

  <!-- â”€â”€ Waiting Room â”€â”€ -->
  <div class="screen" id="waitingScreen">
    <div class="lobby-box">
      <h2>ROOM</h2>
      <div class="room-code-display" id="roomCodeDisplay" onclick="copyCode()"></div>
      <div class="copy-hint">Click code to copy Â· Share with friends</div>
      <ul class="player-list" id="playerList"></ul>
      <div id="waitingStatus" style="color:var(--text-dim); margin-bottom:14px;">
        Waiting for players<span class="waiting-dots"></span>
      </div>
      <button class="btn primary" id="startGameBtn" onclick="socket.emit('startGame')" disabled>START GAME</button>
    </div>
  </div>

  <!-- â”€â”€ Game Screen â”€â”€ -->
  <div class="screen" id="gameScreen">
    <div class="status-bar">
      <span class="phase-label" id="phaseLabel"></span>
      <span class="bid-info" id="bidInfo"></span>
      <span class="coasters-info" id="coastersInfo"></span>
      <span class="round-label" id="roundLabel"></span>
    </div>
    <div class="turn-timer" id="turnTimerWrap" style="display:none;"><div class="turn-timer-bar" id="turnTimerBar"></div></div>
    <div class="message-area" id="messageArea"></div>

    <!-- Revealed flips -->
    <div class="revealed-area" id="revealedArea"></div>

    <!-- Other players -->
    <div class="players-grid" id="playersGrid"></div>

    <!-- Your hand & actions -->
    <div class="your-hand-section" id="yourSection">
      <div class="your-hand-label">YOUR HAND</div>
      <div class="hand-cards" id="yourHand"></div>
      <div class="stack-row" id="yourStack" style="margin-top:10px;"></div>
      <div class="actions-bar" id="actionsBar"></div>
    </div>

    <div class="log-chat-wrapper">
      <div class="game-log" id="gameLog"></div>
      <div class="chat-input-row">
        <input type="text" id="chatInput" placeholder="Type a message..." maxlength="200" autocomplete="off">
        <button onclick="sendChat()">SEND</button>
      </div>
    </div>
  </div>

  <!-- â”€â”€ Win Overlay â”€â”€ -->
  <div class="win-overlay" id="winOverlay">
    <h2 id="winTitle"></h2>
    <p id="winSubtitle"></p>
    <button class="btn primary" id="playAgainBtn" style="display:none" onclick="socket.emit('playAgain')">PLAY AGAIN</button>
    <button class="btn" onclick="document.getElementById('winOverlay').classList.remove('active')">CLOSE</button>
  </div>

  <!-- â”€â”€ Doug Overlay â”€â”€ -->
  <div class="doug-overlay" id="dougOverlay">
    <div class="doug-text">YOU LOSE<br>DOUG!!</div>
    <button class="btn danger doug-close" onclick="closeDougOverlay()">OK</button>
  </div>
</div>

<div class="fixed-btns">
  <button class="circle-btn doug-btn" id="dougBtn" onclick="triggerDoug()" title="DOUG" style="display:none;">ðŸ’¥</button>
  <button class="circle-btn" id="muteBtn" onclick="toggleMute()" title="Sound">ðŸ”Š</button>
  <button class="circle-btn" onclick="toggleStats()" title="Stats">â˜…</button>
  <button class="circle-btn" onclick="toggleRules()" title="Rules">?</button>
</div>

<div class="rules-modal" id="rulesModal">
  <div class="rules-content">
    <button class="close-rules" onclick="toggleRules()">âœ•</button>
    <h3>How to Play Skull</h3>
    Each player has 4 coasters: 3 Roses ðŸŒ¹ and 1 Skull ðŸ’€. The goal is to win 2 challenges.
    <h3>Placing Phase</h3>
    Players take turns placing one coaster face-down onto their stack. Everyone must place at least one before anyone can bid.
    <h3>Bidding Phase</h3>
    Instead of placing, you may start a bid â€” declaring how many coasters you can flip without hitting a skull. Others then raise or pass. The highest bidder must flip that many.
    <h3>Flipping</h3>
    The challenger must flip all their own coasters first, then choose from opponents' stacks (top card only). Reveal a Rose? Keep going. Reveal a Skull? You lose â€” one of your coasters is permanently discarded at random.
    <h3>Winning</h3>
    Flip your full bid count to earn a point. First to 2 points wins. Lose all coasters and you're eliminated.
  </div>
</div>

<div class="stats-modal" id="statsModal">
  <div class="stats-content" id="statsContent">
    <button class="close-stats" onclick="toggleStats()">âœ•</button>
    <h3>Your Stats</h3>
    <div id="statsBody">No stats yet. Play a game!</div>
  </div>
</div>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
const socket = io();
let state = null;
let prevState = null;
let selectedBid = 1;
let lastSeenBid = -1;
let prevRevealedCount = 0;
let timerInterval = null;
let myStackCards = []; // track what I placed (for peek on hover)

const PLAYER_COLORS = ['#d4a843', '#c44569', '#8b9dc3', '#2ecc71', '#e67e22', '#9b59b6'];

// â”€â”€ Sound Effects (Web Audio API) â”€â”€
const SoundFX = {
  ctx: null,
  muted: false,
  init() {
    if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
  },
  play(name) {
    if (this.muted) return;
    this.init();
    const c = this.ctx;
    const now = c.currentTime;
    try { this[name](c, now); } catch(e) {}
  },
  // Short click
  place(c, t) {
    const o = c.createOscillator(); const g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(800, t);
    g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.08);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t+0.08);
  },
  // Rising tone
  bid(c, t) {
    const o = c.createOscillator(); const g = c.createGain();
    o.type = 'triangle'; o.frequency.setValueAtTime(400, t); o.frequency.linearRampToValueAtTime(700, t+0.15);
    g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t+0.2);
  },
  // Low descending
  pass(c, t) {
    const o = c.createOscillator(); const g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(150, t+0.2);
    g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t+0.25);
  },
  // Pleasant chime
  flipRose(c, t) {
    [523, 659, 784].forEach((f, i) => {
      const o = c.createOscillator(); const g = c.createGain();
      o.type = 'sine'; o.frequency.setValueAtTime(f, t + i*0.06);
      g.gain.setValueAtTime(0.1, t + i*0.06); g.gain.exponentialRampToValueAtTime(0.001, t + i*0.06 + 0.3);
      o.connect(g); g.connect(c.destination); o.start(t + i*0.06); o.stop(t + i*0.06 + 0.3);
    });
  },
  // Dramatic buzz
  flipSkull(c, t) {
    const o = c.createOscillator(); const g = c.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(100, t); o.frequency.linearRampToValueAtTime(60, t+0.4);
    g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.5);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t+0.5);
  },
  // FF7 Victory Fanfare
  ff7Victory(c, t) {
    const notes = [
      [466,0.10],[466,0.10],[466,0.10],[466,0.20],
      [370,0.14],[415,0.14],[466,0.45],
      [415,0.14],[466,0.55]
    ];
    let time = t;
    notes.forEach(([freq, dur]) => {
      const o = c.createOscillator(); const g = c.createGain();
      o.type = 'square'; o.frequency.setValueAtTime(freq, time);
      g.gain.setValueAtTime(0.10, time); g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      o.connect(g); g.connect(c.destination); o.start(time); o.stop(time + dur + 0.01);
      // harmony
      const o2 = c.createOscillator(); const g2 = c.createGain();
      o2.type = 'triangle'; o2.frequency.setValueAtTime(freq * 0.5, time);
      g2.gain.setValueAtTime(0.06, time); g2.gain.exponentialRampToValueAtTime(0.001, time + dur);
      o2.connect(g2); g2.connect(c.destination); o2.start(time); o2.stop(time + dur + 0.01);
      time += dur + 0.02;
    });
  },
  // Ewok Celebration (Yub Nub)
  ewokCelebration(c, t) {
    const notes = [
      [392,0.13],[392,0.13],[440,0.13],[494,0.22],
      [392,0.13],[330,0.13],[330,0.13],[392,0.13],
      [440,0.28],[392,0.11],[440,0.11],[494,0.11],
      [587,0.22],[523,0.13],[494,0.13],[440,0.13],[392,0.38]
    ];
    let time = t;
    notes.forEach(([freq, dur], i) => {
      const o = c.createOscillator(); const g = c.createGain();
      o.type = 'triangle'; o.frequency.setValueAtTime(freq, time);
      g.gain.setValueAtTime(0.14, time); g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      o.connect(g); g.connect(c.destination); o.start(time); o.stop(time + dur + 0.01);
      // Add a light percussion hit on downbeats
      if (i % 4 === 0) {
        const buf = c.createBuffer(1, c.sampleRate * 0.05, c.sampleRate);
        const d = buf.getChannelData(0);
        for (let j = 0; j < d.length; j++) d[j] = (Math.random() * 2 - 1) * Math.exp(-j / (c.sampleRate * 0.01));
        const src = c.createBufferSource(); src.buffer = buf;
        const gn = c.createGain(); gn.gain.setValueAtTime(0.08, time); gn.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        src.connect(gn); gn.connect(c.destination); src.start(time);
      }
      time += dur + 0.03;
    });
  },
  // Dark descending
  eliminated(c, t) {
    [300, 250, 200, 150].forEach((f, i) => {
      const o = c.createOscillator(); const g = c.createGain();
      o.type = 'sawtooth'; o.frequency.setValueAtTime(f, t + i*0.12);
      g.gain.setValueAtTime(0.08, t + i*0.12); g.gain.exponentialRampToValueAtTime(0.001, t + i*0.12 + 0.2);
      o.connect(g); g.connect(c.destination); o.start(t + i*0.12); o.stop(t + i*0.12 + 0.2);
    });
  },
  // Fanfare
  gameWin(c, t) {
    [523, 659, 784, 1047, 784, 1047].forEach((f, i) => {
      const o = c.createOscillator(); const g = c.createGain();
      o.type = 'triangle'; o.frequency.setValueAtTime(f, t + i*0.12);
      g.gain.setValueAtTime(0.14, t + i*0.12); g.gain.exponentialRampToValueAtTime(0.001, t + i*0.12 + 0.5);
      o.connect(g); g.connect(c.destination); o.start(t + i*0.12); o.stop(t + i*0.12 + 0.5);
    });
  },
  // Soft pop
  chat(c, t) {
    const o = c.createOscillator(); const g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(600, t); o.frequency.exponentialRampToValueAtTime(900, t+0.05);
    g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.1);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t+0.1);
  },
  // Explosion for Doug button
  dougExplosion(c, t) {
    // White noise burst
    const bufSize = c.sampleRate * 0.5;
    const buf = c.createBuffer(1, bufSize, c.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (c.sampleRate * 0.15));
    const src = c.createBufferSource(); src.buffer = buf;
    const g = c.createGain(); g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.8);
    src.connect(g); g.connect(c.destination); src.start(t);
    // Bass boom
    const o = c.createOscillator(); const g2 = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(60, t); o.frequency.exponentialRampToValueAtTime(20, t+0.5);
    g2.gain.setValueAtTime(0.3, t); g2.gain.exponentialRampToValueAtTime(0.001, t+0.6);
    o.connect(g2); g2.connect(c.destination); o.start(t); o.stop(t+0.6);
  }
};

function toggleMute() {
  SoundFX.muted = !SoundFX.muted;
  const btn = document.getElementById('muteBtn');
  btn.textContent = SoundFX.muted ? 'ðŸ”‡' : 'ðŸ”Š';
  btn.classList.toggle('active', !SoundFX.muted);
}

// â”€â”€ Stats Tracker (localStorage) â”€â”€
const StatsTracker = {
  data: null,
  playerName: null,
  load(name) {
    this.playerName = name;
    try {
      this.data = JSON.parse(localStorage.getItem('skull_stats_' + name)) || this.defaultData();
    } catch(e) { this.data = this.defaultData(); }
  },
  defaultData() {
    return { gamesPlayed: 0, gamesWon: 0, roundsWon: 0, roundsLost: 0,
             skullsPlaced: 0, rosesPlaced: 0, skullsFlipped: 0, rosesFlipped: 0, recentGames: [] };
  },
  save() {
    if (!this.playerName || !this.data) return;
    localStorage.setItem('skull_stats_' + this.playerName, JSON.stringify(this.data));
  },
  inc(key, n) { if (this.data) { this.data[key] = (this.data[key] || 0) + (n || 1); this.save(); } },
  addGame(players, winner, rounds) {
    if (!this.data) return;
    this.data.gamesPlayed++;
    if (winner === this.playerName) this.data.gamesWon++;
    this.data.recentGames.push({ date: new Date().toLocaleDateString(), players, winner, rounds });
    if (this.data.recentGames.length > 20) this.data.recentGames.shift();
    this.save();
  }
};

function toggleStats() {
  const modal = document.getElementById('statsModal');
  modal.classList.toggle('active');
  if (modal.classList.contains('active')) renderStats();
}

function renderStats() {
  const body = document.getElementById('statsBody');
  const d = StatsTracker.data;
  if (!d || !d.gamesPlayed) { body.innerHTML = 'No stats yet. Play a game!'; return; }
  const winRate = d.gamesPlayed > 0 ? Math.round(d.gamesWon / d.gamesPlayed * 100) : 0;
  let html = `
    <div class="stat-row"><span class="stat-label">Games Played</span><span class="stat-value">${d.gamesPlayed}</span></div>
    <div class="stat-row"><span class="stat-label">Games Won</span><span class="stat-value">${d.gamesWon}</span></div>
    <div class="stat-row"><span class="stat-label">Win Rate</span><span class="stat-value">${winRate}%</span></div>
    <div class="stat-row"><span class="stat-label">Rounds Won</span><span class="stat-value">${d.roundsWon}</span></div>
    <div class="stat-row"><span class="stat-label">Rounds Lost</span><span class="stat-value">${d.roundsLost}</span></div>
    <div class="stat-row"><span class="stat-label">Roses Flipped</span><span class="stat-value">${d.rosesFlipped}</span></div>
    <div class="stat-row"><span class="stat-label">Skulls Flipped</span><span class="stat-value">${d.skullsFlipped}</span></div>
    <div class="stat-row"><span class="stat-label">Roses Placed</span><span class="stat-value">${d.rosesPlaced}</span></div>
    <div class="stat-row"><span class="stat-label">Skulls Placed</span><span class="stat-value">${d.skullsPlaced}</span></div>
  `;
  if (d.recentGames && d.recentGames.length > 0) {
    html += '<h3>Recent Games</h3>';
    d.recentGames.slice(-10).reverse().forEach(g => {
      html += `<div class="recent-game"><span class="rg-date">${g.date}</span> â€” <span class="rg-winner">${g.winner}</span> won (${g.rounds} rounds, ${g.players.join(', ')})</div>`;
    });
  }
  body.innerHTML = html;
}

// â”€â”€ Lobby â”€â”€
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function createRoom() {
  const name = document.getElementById('nameInput').value.trim();
  if (!name) { showError('Enter your name.'); return; }
  StatsTracker.load(name);
  socket.emit('createRoom', name, (res) => {
    if (res.success) {
      sessionStorage.setItem('skull_room', res.code);
      sessionStorage.setItem('skull_name', name);
      showScreen('waitingScreen');
      document.getElementById('roomCodeDisplay').textContent = res.code;
    } else showError(res.error);
  });
}

function joinRoom() {
  const name = document.getElementById('nameInput').value.trim();
  const code = document.getElementById('codeInput').value.trim().toUpperCase();
  if (!name) { showError('Enter your name.'); return; }
  if (!code || code.length !== 4) { showError('Enter a 4-letter room code.'); return; }
  StatsTracker.load(name);
  socket.emit('joinRoom', { name, code }, (res) => {
    if (res.success) {
      sessionStorage.setItem('skull_room', res.code);
      sessionStorage.setItem('skull_name', name);
      showScreen('waitingScreen');
      document.getElementById('roomCodeDisplay').textContent = res.code;
    } else showError(res.error);
  });
}

function showError(msg) { document.getElementById('lobbyError').textContent = msg; }

function copyCode() {
  const code = document.getElementById('roomCodeDisplay').textContent;
  navigator.clipboard.writeText(code).catch(() => {});
}

// â”€â”€ Chat â”€â”€
function sendChat() {
  const input = document.getElementById('chatInput');
  const msg = input.value.trim();
  if (!msg) return;
  socket.emit('chatMessage', msg);
  input.value = '';
}

// â”€â”€ Sound Detection (diff state) â”€â”€
function detectSounds(prev, curr) {
  if (!prev || !curr) return;

  // New revealed cards
  const prevRC = prev.revealedCards ? prev.revealedCards.length : 0;
  const currRC = curr.revealedCards ? curr.revealedCards.length : 0;
  if (currRC > prevRC) {
    const newCard = curr.revealedCards[currRC - 1];
    if (newCard.card === 'skull') SoundFX.play('flipSkull');
    else SoundFX.play('flipRose');
  }

  // Phase transitions
  if (prev.phase !== curr.phase) {
    if (curr.phase === 'bidding') SoundFX.play('bid');
  }

  // Bid raised
  if (prev.currentBid < curr.currentBid && prev.phase === 'bidding' && curr.phase === 'bidding') {
    SoundFX.play('bid');
  }

  // Coaster placed
  if (curr.phase === 'placing' && prev.totalCoastersOnTable < curr.totalCoastersOnTable) {
    SoundFX.play('place');
  }

  // Check for new log entries with specific patterns
  const prevLogLen = prev.log ? prev.log.length : 0;
  const currLogLen = curr.log ? curr.log.length : 0;
  if (currLogLen > prevLogLen) {
    const newLogs = curr.log.slice(prevLogLen);
    for (const l of newLogs) {
      if (l.includes('wins a point')) {
        if (l.toLowerCase().includes('ewok')) SoundFX.play('ewokCelebration');
        else SoundFX.play('ff7Victory');
      }
      else if (l.includes('is eliminated')) SoundFX.play('eliminated');
      else if (l.includes('passed')) SoundFX.play('pass');
      else if (l.startsWith('ðŸ’¬') && !l.includes(curr.players[curr.myIndex]?.name + ':')) SoundFX.play('chat');
    }
  }
}

// â”€â”€ Timer â”€â”€
function updateTimer() {
  if (!state || !state.turnDeadline) {
    document.getElementById('turnTimerWrap').style.display = 'none';
    return;
  }
  const remaining = state.turnDeadline - Date.now();
  const total = 20000;
  if (remaining <= 0) {
    document.getElementById('turnTimerWrap').style.display = 'none';
    return;
  }
  const pct = Math.max(0, (remaining / total) * 100);
  const bar = document.getElementById('turnTimerBar');
  const wrap = document.getElementById('turnTimerWrap');
  wrap.style.display = 'block';
  bar.style.width = pct + '%';
  if (pct > 50) bar.style.backgroundColor = 'var(--success)';
  else if (pct > 25) bar.style.backgroundColor = 'var(--gold)';
  else bar.style.backgroundColor = 'var(--danger)';
}

// â”€â”€ Game State â”€â”€
socket.on('gameState', (s) => {
  prevState = state;
  state = s;
  detectSounds(prevState, s);
  // Reset stack tracking on new round
  if (s.started && s.players[s.myIndex] && s.players[s.myIndex].stackCount === 0) {
    myStackCards = [];
  }
  if (!s.started) {
    renderWaiting();
  } else {
    showScreen('gameScreen');
    renderGame();
  }
  // Start timer interval
  if (timerInterval) clearInterval(timerInterval);
  if (s.turnDeadline) {
    timerInterval = setInterval(updateTimer, 200);
    updateTimer();
  } else {
    document.getElementById('turnTimerWrap').style.display = 'none';
  }
});

socket.on('message', (msg) => {
  // Messages also come via log in state
});

socket.on('gameOver', ({ winnerName, winnerIndex }) => {
  const overlay = document.getElementById('winOverlay');
  const isMe = state && state.myIndex === winnerIndex;
  document.getElementById('winTitle').textContent = isMe ? 'ðŸ† VICTORY!' : 'ðŸ’€ DEFEAT';
  document.getElementById('winSubtitle').textContent = isMe ? 'You have proven your nerve!' : `${winnerName} claims the victory.`;
  document.getElementById('playAgainBtn').style.display = state.isHost ? 'inline-block' : 'none';
  overlay.classList.add('active');
  if (isMe) SoundFX.play('gameWin'); else SoundFX.play('eliminated');
  // Record stats
  if (state) {
    const players = state.players.map(p => p.name);
    StatsTracker.addGame(players, winnerName, state.roundNum);
  }
});

// â”€â”€ Waiting Room Render â”€â”€
function renderWaiting() {
  showScreen('waitingScreen');
  const list = document.getElementById('playerList');
  list.innerHTML = '';
  state.players.forEach((p, i) => {
    const li = document.createElement('li');
    const color = PLAYER_COLORS[p.colorIndex % PLAYER_COLORS.length];
    let badges = '';
    if (i === 0) badges += '<span class="host-badge">HOST</span> ';
    if (p.isMe) badges += '<span class="you-badge">YOU</span>';
    li.innerHTML = `<span><span class="player-color-dot" style="background:${color}"></span>${p.name}</span><span>${badges}</span>`;
    list.appendChild(li);
  });
  const btn = document.getElementById('startGameBtn');
  btn.disabled = !(state.isHost && state.players.length >= 2);
  btn.textContent = state.isHost ? (state.players.length < 2 ? 'NEED 2+ PLAYERS' : 'START GAME') : 'WAITING FOR HOST';
}

// â”€â”€ Game Render â”€â”€
function renderGame() {
  if (!state) return;
  const me = state.players[state.myIndex];
  const isMyTurn = state.currentPlayer === state.myIndex;

  // Status bar
  const phaseNames = { placing: 'Placing Phase', bidding: 'Bidding Phase', flipping: 'Flipping Phase', flip_result: 'Flipping Phase', penalty: 'Penalty', gameover: 'Game Over' };
  document.getElementById('phaseLabel').textContent = phaseNames[state.phase] || '';
  document.getElementById('roundLabel').textContent = `Round ${state.roundNum}`;
  document.getElementById('bidInfo').textContent = state.phase === 'bidding' || state.phase === 'flipping' || state.phase === 'flip_result' ?
    `Bid: ${state.currentBid} by ${state.players[state.highestBidder]?.name || '?'}` : '';
  document.getElementById('coastersInfo').textContent = state.totalCoastersOnTable > 0 ? `${state.totalCoastersOnTable} on table` : '';

  // Message
  renderMessage(me, isMyTurn);

  // Revealed cards
  renderRevealed();

  // Players grid (all players including me)
  renderPlayersGrid(me, isMyTurn);

  // Your hand + actions
  renderYourHand(me, isMyTurn);

  // Log
  renderLog();

  // Track stats for placing
  if (prevState && state.phase === 'placing' && prevState.totalCoastersOnTable < state.totalCoastersOnTable) {
    // A card was placed â€” check if it was mine by comparing my stack count
    const prevMe = prevState.players[prevState.myIndex];
    if (prevMe && me.stackCount > prevMe.stackCount) {
      // I placed a card â€” we can't tell which, so just count a place
    }
  }

  // Track stats for flips
  if (prevState) {
    const prevRC = prevState.revealedCards ? prevState.revealedCards.length : 0;
    const currRC = state.revealedCards ? state.revealedCards.length : 0;
    if (currRC > prevRC) {
      const newCard = state.revealedCards[currRC - 1];
      if (newCard.card === 'skull') StatsTracker.inc('skullsFlipped');
      else StatsTracker.inc('rosesFlipped');
    }
  }

  // Doug button visibility
  const dougBtn = document.getElementById('dougBtn');
  const myName = state.players[state.myIndex]?.name || '';
  dougBtn.style.display = (myName.toLowerCase() === 'pat-wins') ? 'flex' : 'none';

  // Track round wins/losses
  if (prevState && prevState.roundNum < state.roundNum) {
    // Round changed â€” check if we won or lost
    const prevMe = prevState.players[prevState.myIndex];
    if (prevMe && me.wins > prevMe.wins) StatsTracker.inc('roundsWon');
    else if (prevState.phase === 'flip_result' || prevState.phase === 'penalty') StatsTracker.inc('roundsLost');
  }
}

function renderMessage(me, isMyTurn) {
  const area = document.getElementById('messageArea');
  const turnPlayer = state.players[state.currentPlayer];

  if (state.phase === 'penalty') {
    const penaltyP = state.players[state.penaltyPlayer];
    if (state.penaltyPlayer === state.myIndex) {
      area.innerHTML = 'You hit your own skull! <span class="skull-hl">Choose a coaster to discard.</span>';
    } else {
      area.innerHTML = `<span class="hl">${penaltyP?.name}</span> is choosing a coaster to discard...`;
    }
    return;
  }

  if (!turnPlayer) { area.innerHTML = ''; return; }

  if (state.phase === 'placing') {
    if (isMyTurn) {
      if (me.hand && me.hand.length === 0) {
        area.innerHTML = 'No cards left â€” you must <span class="hl">Start Bidding</span>.';
      } else if (state.firstPlacement) {
        area.innerHTML = me.stackCount === 0 ? 'Place a coaster to begin.' : 'Waiting for all players to place their first coaster...';
      } else {
        area.innerHTML = 'Place a coaster or <span class="hl">Start Bidding</span>.';
      }
    } else {
      area.innerHTML = state.firstPlacement
        ? `Waiting for all players to place a coaster... (<span class="hl">${turnPlayer.name}</span>'s turn)`
        : `Waiting for <span class="hl">${turnPlayer.name}</span> to place or bid...`;
    }
  } else if (state.phase === 'bidding') {
    const bidder = state.players[state.highestBidder];
    if (me.passed) {
      area.innerHTML = `You passed. Current bid: <span class="hl">${state.currentBid}</span> by <span class="hl">${bidder?.name}</span>. Waiting for others...`;
    } else if (state.myIndex === state.highestBidder) {
      area.innerHTML = `Your bid of <span class="hl">${state.currentBid}</span> is the highest. Waiting for others to raise or pass...`;
    } else {
      area.innerHTML = `<span class="hl">${bidder?.name}</span> bid <span class="hl">${state.currentBid}</span>. Raise or pass!`;
    }
  } else if (state.phase === 'flipping' || state.phase === 'flip_result') {
    const flipper = state.players[state.highestBidder];
    if (state.highestBidder === state.myIndex) {
      if (me.stackCount > 0) {
        area.innerHTML = `Flip your own stack first! <span class="hl">${state.flipsRemaining}</span> remaining.`;
      } else {
        area.innerHTML = `Choose an opponent's coaster to flip. <span class="hl">${state.flipsRemaining}</span> remaining.`;
      }
    } else {
      area.innerHTML = `<span class="hl">${flipper?.name}</span> is flipping... ${state.flipsRemaining} remaining.`;
    }
  }
}

function renderRevealed() {
  const area = document.getElementById('revealedArea');
  const cards = state.revealedCards || [];
  // Only re-render if count changed
  if (area.childElementCount === cards.length) return;
  area.innerHTML = '';
  cards.forEach(rc => {
    const div = document.createElement('div');
    div.className = 'revealed-card';
    div.innerHTML = `<div class="coaster ${rc.card}"></div><span class="rc-name">${rc.playerName}</span>`;
    area.appendChild(div);
  });
}

function renderPlayersGrid(me, isMyTurn) {
  const grid = document.getElementById('playersGrid');
  grid.innerHTML = '';

  state.players.forEach((p, i) => {
    if (p.isMe) return; // skip self â€” shown below

    const color = PLAYER_COLORS[p.colorIndex % PLAYER_COLORS.length];
    const zone = document.createElement('div');
    let cls = 'player-zone';
    const isActiveTurn = state.phase === 'bidding' ? i === state.highestBidder : state.currentPlayer === i;
    if (isActiveTurn) cls += ' active-turn';
    if (p.eliminated) cls += ' eliminated';
    if (!p.connected) cls += ' disconnected';
    zone.className = cls;
    zone.style.borderLeftWidth = '3px';
    zone.style.borderLeftColor = color;

    // Header
    let statusBadge = '';
    if (!p.connected) statusBadge = '<span style="color:var(--danger);font-size:0.7rem;">OFFLINE</span>';
    if (p.eliminated) statusBadge = '<span style="color:var(--danger);font-size:0.7rem;">OUT</span>';
    if (p.passed && state.phase === 'bidding') statusBadge = '<span style="color:var(--text-dim);font-size:0.7rem;">PASSED</span>';

    zone.innerHTML = `
      <div class="pz-header">
        <span class="pz-name" style="color:${color}">${p.name}</span>
        <div class="pz-wins">
          <div class="win-pip ${p.wins >= 1 ? 'earned' : ''}"></div>
          <div class="win-pip ${p.wins >= 2 ? 'earned' : ''}"></div>
        </div>
      </div>
      <div class="pz-cards-info">${p.totalCards} coaster${p.totalCards !== 1 ? 's' : ''} ${statusBadge}</div>
      <div class="stack-row" id="stack_${i}"></div>
    `;
    grid.appendChild(zone);

    // Stack coasters â€” only top (last) coaster is flippable
    const stackRow = zone.querySelector('.stack-row');
    for (let s = 0; s < p.stackCount; s++) {
      const c = document.createElement('div');
      const isTopCard = (s === p.stackCount - 1);
      const canFlip = isTopCard &&
        state.phase === 'flipping' &&
        state.highestBidder === state.myIndex &&
        state.flipsRemaining > 0 &&
        me.stackCount === 0;
      c.className = 'coaster facedown' + (canFlip ? ' flippable' : '');
      if (canFlip) c.onclick = () => socket.emit('flipCoaster', i);
      stackRow.appendChild(c);
    }
    // In-hand indicators
    const inHand = p.handCount || 0;
    for (let h = 0; h < inHand; h++) {
      const c = document.createElement('div');
      c.className = 'coaster in-hand';
      stackRow.appendChild(c);
    }
  });
}

function renderYourHand(me, isMyTurn) {
  const section = document.getElementById('yourSection');
  const isMyTurnHighlight = state.phase === 'bidding'
    ? (state.myIndex === state.highestBidder)
    : isMyTurn;
  section.className = 'your-hand-section' + (isMyTurnHighlight ? ' your-turn' : '');

  // Hand cards
  const handEl = document.getElementById('yourHand');
  handEl.innerHTML = '';
  if (me.hand && !me.eliminated) {
    me.hand.forEach((card, idx) => {
      const canPlace = state.phase === 'placing' && isMyTurn;
      const div = document.createElement('div');
      div.className = `hand-card ${card === 'rose' ? 'rose-card' : 'skull-card'} ${!canPlace ? 'disabled' : ''}`;
      div.innerHTML = card === 'rose' ? 'ðŸŒ¹' : 'ðŸ’€';
      if (canPlace) div.onclick = () => {
        myStackCards.push(card);
        socket.emit('placeCard', idx);
        if (card === 'rose') StatsTracker.inc('rosesPlaced');
        else StatsTracker.inc('skullsPlaced');
      };
      handEl.appendChild(div);
    });
  }

  // Your stack â€” only top coaster flippable
  const stackEl = document.getElementById('yourStack');
  stackEl.innerHTML = '';
  const myP = state.players[state.myIndex];
  for (let s = 0; s < myP.stackCount; s++) {
    const c = document.createElement('div');
    const isTopCard = (s === myP.stackCount - 1);
    const canFlipOwn = isTopCard && state.phase === 'flipping' && state.highestBidder === state.myIndex && state.flipsRemaining > 0 && myP.stackCount > 0;
    let cls = 'coaster facedown';
    if (canFlipOwn) cls += ' flippable';
    // Peek on hover for your own stack
    if (myStackCards[s]) {
      cls += ' peekable peek-' + myStackCards[s];
    }
    c.className = cls;
    if (canFlipOwn) c.onclick = () => socket.emit('flipCoaster', state.myIndex);
    stackEl.appendChild(c);
  }
  // Your win pips
  let winsHTML = `<div style="display:flex;gap:4px;justify-content:center;margin-top:6px;">
    <div class="win-pip ${myP.wins >= 1 ? 'earned' : ''}"></div>
    <div class="win-pip ${myP.wins >= 2 ? 'earned' : ''}"></div>
    <span style="font-size:0.75rem;color:var(--text-dim);margin-left:6px;">${myP.totalCards} coasters</span>
  </div>`;
  // Append or update
  let winsEl = document.getElementById('yourWinsInfo');
  if (!winsEl) {
    winsEl = document.createElement('div');
    winsEl.id = 'yourWinsInfo';
    stackEl.parentElement.insertBefore(winsEl, stackEl);
  }
  winsEl.innerHTML = winsHTML;

  // Actions
  renderActions(me, isMyTurn);
}

function renderActions(me, isMyTurn) {
  const bar = document.getElementById('actionsBar');
  bar.innerHTML = '';

  if (me.eliminated) return;

  // Penalty: show card picker for own-skull penalty
  if (state.phase === 'penalty' && state.penaltyPlayer === state.myIndex && state.penaltyCards) {
    const label = document.createElement('div');
    label.style.cssText = 'width:100%;text-align:center;font-family:Cinzel,serif;color:var(--skull);margin-bottom:8px;';
    label.textContent = 'Click a coaster to discard it:';
    bar.appendChild(label);

    const cardRow = document.createElement('div');
    cardRow.style.cssText = 'display:flex;gap:18px;justify-content:center;flex-wrap:wrap;';
    state.penaltyCards.forEach((card, idx) => {
      const div = document.createElement('div');
      div.className = `hand-card ${card === 'rose' ? 'rose-card' : 'skull-card'}`;
      div.innerHTML = card === 'rose' ? 'ðŸŒ¹' : 'ðŸ’€';
      div.onclick = () => socket.emit('penaltyDiscard', idx);
      cardRow.appendChild(div);
    });
    bar.appendChild(cardRow);
    return;
  }

  // Placing: show "Start Bid" with amount picker
  if (state.phase === 'placing' && isMyTurn) {
    if (!state.firstPlacement && me.stackCount > 0) {
      const maxBid = state.totalCoastersOnTable;
      if (lastSeenBid !== 0) { selectedBid = 1; lastSeenBid = 0; }
      selectedBid = Math.max(1, Math.min(selectedBid, maxBid));

      if (maxBid >= 1) {
        const controls = document.createElement('div');
        controls.className = 'bid-controls';

        const down = document.createElement('button');
        down.className = 'bid-arrow';
        down.innerHTML = 'â—€';
        down.disabled = selectedBid <= 1;
        down.onclick = () => { if (selectedBid > 1) { selectedBid--; renderActions(me, isMyTurn); } };

        const num = document.createElement('div');
        num.className = 'bid-number';
        num.textContent = selectedBid;

        const up = document.createElement('button');
        up.className = 'bid-arrow';
        up.innerHTML = 'â–¶';
        up.disabled = selectedBid >= maxBid;
        up.onclick = () => { if (selectedBid < maxBid) { selectedBid++; renderActions(me, isMyTurn); } };

        controls.append(down, num, up);
        bar.appendChild(controls);
      }

      const btn = document.createElement('button');
      btn.className = 'btn primary sm';
      btn.textContent = 'START BIDDING';
      btn.onclick = () => socket.emit('startBid', selectedBid);
      bar.appendChild(btn);
    }
  }

  // Bidding: free-for-all â€” show bid/pass for anyone who hasn't passed and isn't the highest bidder
  if (state.phase === 'bidding' && !me.passed && !me.eliminated && state.myIndex !== state.highestBidder) {
    const minBid = state.currentBid + 1;
    const maxBid = state.totalCoastersOnTable;
    if (lastSeenBid !== state.currentBid) { selectedBid = minBid; lastSeenBid = state.currentBid; }
    selectedBid = Math.max(selectedBid, minBid);
    if (selectedBid > maxBid) selectedBid = maxBid;

    if (minBid <= maxBid) {
      const controls = document.createElement('div');
      controls.className = 'bid-controls';

      const down = document.createElement('button');
      down.className = 'bid-arrow';
      down.innerHTML = 'â—€';
      down.disabled = selectedBid <= minBid;
      down.onclick = () => { if (selectedBid > minBid) { selectedBid--; renderActions(me, isMyTurn); } };

      const num = document.createElement('div');
      num.className = 'bid-number';
      num.textContent = selectedBid;

      const up = document.createElement('button');
      up.className = 'bid-arrow';
      up.innerHTML = 'â–¶';
      up.disabled = selectedBid >= maxBid;
      up.onclick = () => { if (selectedBid < maxBid) { selectedBid++; renderActions(me, isMyTurn); } };

      controls.append(down, num, up);
      bar.appendChild(controls);

      const bidBtn = document.createElement('button');
      bidBtn.className = 'btn primary sm';
      bidBtn.textContent = 'BID';
      bidBtn.onclick = () => socket.emit('raiseBid', selectedBid);
      bar.appendChild(bidBtn);
    }

    const passBtn = document.createElement('button');
    passBtn.className = 'btn danger sm';
    passBtn.textContent = 'PASS';
    passBtn.onclick = () => socket.emit('pass');
    bar.appendChild(passBtn);
  }
}

function renderLog() {
  const el = document.getElementById('gameLog');
  const colors = {};
  if (state && state.players) {
    state.players.forEach(p => { colors[p.name] = PLAYER_COLORS[p.colorIndex % PLAYER_COLORS.length]; });
  }
  el.innerHTML = (state.log || []).map(l => {
    // Style chat messages with player color
    if (l.startsWith('ðŸ’¬ ')) {
      const match = l.match(/^ðŸ’¬ ([^:]+): (.*)$/);
      if (match) {
        const c = colors[match[1]] || 'var(--text-dim)';
        return `<div><span style="color:${c};font-weight:600;">ðŸ’¬ ${match[1]}:</span> ${match[2]}</div>`;
      }
    }
    return `<div>${l}</div>`;
  }).join('');
  el.scrollTop = el.scrollHeight;
}

function toggleRules() { document.getElementById('rulesModal').classList.toggle('active'); }

// Enter key on inputs
document.getElementById('nameInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') { if (document.getElementById('codeInput').value) joinRoom(); } });
document.getElementById('codeInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') joinRoom(); });
document.getElementById('chatInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChat(); });

// â”€â”€ Doug Button â”€â”€
function triggerDoug() {
  socket.emit('dougLose');
}

function showDougExplosion() {
  SoundFX.play('dougExplosion');
  const overlay = document.getElementById('dougOverlay');
  overlay.classList.add('active');
  // Spawn particles
  for (let i = 0; i < 50; i++) {
    const p = document.createElement('div');
    p.className = 'doug-particle';
    const size = Math.random() * 20 + 5;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    const colors = ['#ff0000', '#ff4400', '#ff8800', '#ffcc00', '#ff0066', '#ff2200'];
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.left = '50%';
    p.style.top = '50%';
    p.style.opacity = '1';
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * 700 + 200;
    const dx = Math.cos(angle) * dist;
    const dy = Math.sin(angle) * dist;
    p.style.transition = `all ${1 + Math.random()}s ease-out`;
    overlay.appendChild(p);
    requestAnimationFrame(() => {
      p.style.left = `calc(50% + ${dx}px)`;
      p.style.top = `calc(50% + ${dy}px)`;
      p.style.opacity = '0';
    });
    setTimeout(() => p.remove(), 2000);
  }
  setTimeout(() => closeDougOverlay(), 5000);
}

function closeDougOverlay() {
  document.getElementById('dougOverlay').classList.remove('active');
}

socket.on('dougLose', () => {
  showDougExplosion();
});

// â”€â”€ Auto-Rejoin on Reload â”€â”€
(function() {
  const savedRoom = sessionStorage.getItem('skull_room');
  const savedName = sessionStorage.getItem('skull_name');
  if (savedRoom && savedName) {
    document.getElementById('nameInput').value = savedName;
    StatsTracker.load(savedName);
    socket.emit('joinRoom', { name: savedName, code: savedRoom }, (res) => {
      if (res.success) {
        document.getElementById('roomCodeDisplay').textContent = res.code;
        showScreen('waitingScreen');
      } else {
        sessionStorage.removeItem('skull_room');
        sessionStorage.removeItem('skull_name');
      }
    });
  }
})();
</script>

</body>
</html>
